/**
 * Expert Guidance Agent
 * Provides real-time coaching and guidance during simulations
 */

import { BaseAgent, ChatMessage, AgentResponse } from './base-agent.js';
import { AGENT_NAMES } from './agent-config.js';
import { SimulationContext, ClientProfile, ObjectiveProgress } from './simulation-client-agent.js';

export interface GuidanceRequest {
  messages: ChatMessage[];
  clientProfile: ClientProfile;
  personalitySettings: {
    mood: string;
    archetype: string;
    traits: Record<string, number>;
    influence: string;
  };
  simulationSettings: {
    industry: string;
    subcategory?: string;
    difficulty: string;
    competencies?: string[];
    focusAreas?: Array<{ id: string; name: string }>;
  };
  objectives?: Array<{ name: string; progress: number }>;
  sessionId: string;
}

export interface GuidanceResponse {
  success: boolean;
  message: string;
  tier: number;
  metadata?: Record<string, any>;
}

// In-memory context store for guidance sessions
const guidanceContextStore = new Map<string, {
  objectives: Array<{ name: string; progress: number }>;
  context: any;
}>();

/**
 * Expert Guidance Agent Implementation
 */
export class ExpertGuidanceAgent extends BaseAgent {
  constructor() {
    super(AGENT_NAMES.EXPERT_GUIDANCE);
  }

  /**
   * Register tool handlers
   */
  protected registerToolHandlers(): void {
    this.toolHandlers.set('get_objectives', this.handleGetObjectives.bind(this));
    this.toolHandlers.set('get_context', this.handleGetContext.bind(this));
    this.toolHandlers.set('generate_guidance', this.handleGenerateGuidance.bind(this));
  }

  /**
   * Tool: Get objectives
   */
  private async handleGetObjectives(args: { session_id: string }): Promise<Array<{ name: string; progress: number }>> {
    const stored = guidanceContextStore.get(args.session_id);
    if (stored?.objectives) {
      return stored.objectives;
    }

    // Return default objectives
    return [
      { name: 'Building Rapport', progress: 0 },
      { name: 'Needs Assessment', progress: 0 },
      { name: 'Handling Objections', progress: 0 },
      { name: 'Providing Recommendations', progress: 0 },
    ];
  }

  /**
   * Tool: Get context
   */
  private async handleGetContext(args: {
    session_id: string;
    include_history?: boolean;
  }): Promise<any> {
    const stored = guidanceContextStore.get(args.session_id);
    return stored?.context || { error: 'Context not found' };
  }

  /**
   * Tool: Generate guidance
   */
  private async handleGenerateGuidance(args: {
    guidance_type: 'factual' | 'coaching' | 'comprehensive';
    topic: string;
    context?: any;
  }): Promise<any> {
    return {
      type: args.guidance_type,
      topic: args.topic,
      generated: true,
      // The actual guidance will be generated by the agent itself
    };
  }

  /**
   * Set context for a guidance session
   */
  setContext(
    sessionId: string,
    objectives: Array<{ name: string; progress: number }>,
    context: any
  ): void {
    guidanceContextStore.set(sessionId, { objectives, context });
  }

  /**
   * Generate expert guidance
   */
  async generateGuidance(request: GuidanceRequest): Promise<GuidanceResponse> {
    // Store context for tool access
    this.setContext(request.sessionId, request.objectives || [], {
      clientProfile: request.clientProfile,
      personality: request.personalitySettings,
      simulation: request.simulationSettings,
    });

    // Determine the response tier based on the question
    const lastUserMessage = request.messages.filter(m => m.role === 'user').pop()?.content || '';
    const tier = this.determineResponseTier(lastUserMessage);

    // Build enhanced context
    const context = {
      sessionId: request.sessionId,
      tier,
      clientProfile: {
        name: request.clientProfile.name,
        age: request.clientProfile.age,
        occupation: request.clientProfile.occupation,
        goals: request.clientProfile.goals,
      },
      simulation: {
        industry: request.simulationSettings.industry,
        subcategory: request.simulationSettings.subcategory,
        difficulty: request.simulationSettings.difficulty,
        competencies: request.simulationSettings.competencies,
      },
      objectives: request.objectives,
      responseFormat: this.getResponseFormat(tier),
    };

    // Build system prompt
    const systemPrompt = this.buildExpertSystemPrompt(request, tier);

    const messages: ChatMessage[] = [
      { role: 'system', content: systemPrompt },
      ...request.messages.filter(m => m.role !== 'system'),
    ];

    const response = await this.chat(messages, context);

    return {
      success: response.success,
      message: response.message,
      tier,
      metadata: response.metadata,
    };
  }

  /**
   * Determine response tier based on the question
   */
  private determineResponseTier(question: string): number {
    const q = question.toLowerCase().trim();

    // Very short messages are likely simple factual questions
    if (q.length < 100) {
      // Check for factual indicators
      const factualIndicators = ['what is', 'explain', 'difference between', 'types of', 'how does', 'describe'];
      for (const indicator of factualIndicators) {
        if (q.includes(indicator)) return 1;
      }
    }

    let factualScore = 0;
    let coachingScore = 0;

    // Factual indicators
    const factualPatterns = ['what is', 'explain', 'difference between', 'types of', 'how does', 'describe'];
    const coachingPatterns = ['how do i', 'what should i', 'strategy for', 'tips for', 'handle', 'respond to'];

    // Topic keywords
    const factualTopics = ['insurance', 'policy', 'annuity', 'premium', 'coverage', 'rider'];
    const coachingTopics = ['client', 'objection', 'recommend', 'approach', 'persuade', 'rapport'];

    // Calculate scores
    factualPatterns.forEach(p => { if (q.includes(p)) factualScore += 2; });
    coachingPatterns.forEach(p => { if (q.includes(p)) coachingScore += 2; });
    factualTopics.forEach(t => { if (q.includes(t)) factualScore += 1; });
    coachingTopics.forEach(t => { if (q.includes(t)) coachingScore += 1; });

    // Complex questions often have multiple parts
    if (q.includes(' and ') || q.includes(' or ') || q.includes(',')) {
      return 3;
    }

    // Determine tier based on scores
    if (factualScore > coachingScore && factualScore > 2) return 1;
    if (coachingScore > factualScore && coachingScore > 2) return 2;

    // Default to comprehensive response
    return 3;
  }

  /**
   * Get response format for a tier
   */
  private getResponseFormat(tier: number): string {
    if (tier === 1) {
      return `
FORMAT YOUR RESPONSE USING THIS SIMPLIFIED STRUCTURE:

## Expert Summary
• [Key fact about the topic - 3-4 bullet points only]

## Client-Friendly Explanation
[A simple, conversational explanation in 1 paragraph that the advisor can use directly with the client. Use plain language and avoid jargon.]

Need more detail? Ask for "more info on [topic]" or "coaching on [topic]".`;
    }

    if (tier === 2) {
      return `
FORMAT YOUR RESPONSE USING THIS COACHING STRUCTURE:

## Situation Assessment
[Brief assessment of the current client situation and conversation progress]

## Strategic Coaching
[2-3 clear, actionable steps for the advisor]

## Sample Questions
[2-3 specific questions the advisor could ask the client]`;
    }

    return `
FORMAT YOUR RESPONSE USING THIS COMPREHENSIVE STRUCTURE:

## Expert Information
[Provide clear, accurate, and detailed information about the specific financial topic]

## Sample Client Dialogue
[Provide a concise example of how to explain this concept to the client in simple language]

## Situation Assessment
[Brief assessment of the current client situation and conversation progress]

## Recommended Next Steps
1. [Clear, actionable step]
2. [Clear, actionable step]
3. [Clear, actionable step]

## Key Questions to Ask
- [Specific question]
- [Specific question]
- [Specific question]

This is a high-level guide. If you need more detail on any part, ask again for a breakdown.`;
  }

  /**
   * Build expert system prompt
   */
  private buildExpertSystemPrompt(request: GuidanceRequest, tier: number): string {
    const competenciesText = Array.isArray(request.simulationSettings.competencies)
      ? request.simulationSettings.competencies.join(', ')
      : 'None specified';

    const objectivesText = request.objectives && Array.isArray(request.objectives)
      ? request.objectives.map(obj => `- ${obj.name}: ${obj.progress}% complete`).join('\n')
      : 'No objectives data available';

    return `You are an expert financial advisor trainer providing guidance to an advisor in a simulation.
The advisor is practicing with a simulated client and has asked for your help.

Client Profile:
- Name: ${request.clientProfile.name || 'Unknown'}
- Age: ${request.clientProfile.age || 'Unknown'}
- Occupation: ${request.clientProfile.occupation || 'Unknown'}
- Goals: ${Array.isArray(request.clientProfile.goals) ? request.clientProfile.goals.join(', ') : 'Unknown'}

Industry Context: ${request.simulationSettings.industry || 'Unknown'}${request.simulationSettings.subcategory ? ` - ${request.simulationSettings.subcategory}` : ''}
Difficulty Level: ${request.simulationSettings.difficulty || 'Unknown'}

Competencies Being Evaluated: ${competenciesText}

Current Objectives Progress:
${objectivesText}

IMPORTANT: I've analyzed your question and will provide a Tier ${tier} response tailored to what you need.

IMPORTANT: You MUST follow the response format for Tier ${tier}. Do not include additional sections.

⚠️ RISK MITIGATION GUIDELINES:
- Never invent features, tax benefits, guarantees, or product endorsements
- Do not claim that annuities guarantee growth or income unless qualified
- Avoid recommending "the best" insurance policy — instead, compare types generally
- Include disclaimers when appropriate
- If a topic requires licensed expertise, note that the client should consult a licensed professional

${this.getResponseFormat(tier)}

When providing feedback, be concise, practical, and supportive in your guidance.

Remember that you are NOT the client - you are a trainer helping the advisor succeed in this simulation.`;
  }
}

// Export singleton instance
export const expertGuidanceAgent = new ExpertGuidanceAgent();

export default expertGuidanceAgent;
